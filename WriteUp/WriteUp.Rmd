---
# IMPORTANT: Change settings here, but DO NOT change the spacing.
# Remove comments and add values where applicable.
# The descriptions below should be self-explanatory

title: "Time-varying Correlations Between Sectors of the All Share Index"
#subtitle: "This will appear as Right Header"

documentclass: "elsarticle"

# --------- Thesis title (Optional - set to FALSE by default).
# You can move the details below around as you please.
Thesis_FP: FALSE
# Entry1: "An unbelievable study with a title spanning multiple lines."
# Entry2: "\\textbf{Some Guy}" # textbf for bold
# Entry3: "A thesis submitted toward the degree of Doctor of Philosophy"
# Uni_Logo: Tex/Logo.png # Place a logo in the indicated location (from your root, e.g. defaults to ~/Tex/Logo.png) and uncomment this line. Leave uncommented for no image
# Logo_width: 0.3 # If using a logo - use this to set width (size) of image
# Entry4: "Under the supervision of: \\vfill Prof. Joe Smith and Dr. Frank Smith"
# Entry5: "Stellenbosch University"
# Entry6: April 2020
# Entry7:
# Entry8:

# --------- Front Page
# Comment: ----- Follow this pattern for up to 5 authors
AddTitle: TRUE # Use FALSE when submitting to peer reviewed platform. This will remove author names.
Author1: "Wesley Williams"  # First Author - note the thanks message displayed as an italic footnote of first page.
Ref1: "Final Project for Financial Econometrics 871 at Stellenosch University, South Africa" # First Author's Affiliation
Email1: "21691126\\@sun.ac.za" # First Author's Email address

# Author2: "John Smith"
# Ref2: "Some other Institution, Cape Town, South Africa"
# Email2: "John\\@gmail.com"
# CommonAffiliation_12: TRUE # If Author 1 and 2 have a common affiliation. Works with _13, _23, etc.
# 
# Author3: "John Doe"
# Email3: "Joe\\@gmail.com"
# 
# CorrespAuthor_1: TRUE  # If corresponding author is author 3, e.g., use CorrespAuthor_3: TRUE

# Comment out below to remove both. JEL Codes only given if keywords also given.
# keywords: "Multivariate GARCH \\sep ALSI \\sep Sectors" # Use \\sep to separate
# JELCodes: "L250 \\sep L100"

# ----- Manage headers and footers:
#BottomLFooter: $Title$
#BottomCFooter:
#TopLHeader: \leftmark # Adds section name at topleft. Remove comment to add it.
BottomRFooter: "\\footnotesize Page \\thepage" # Add a '#' before this line to remove footer.
addtoprule: TRUE
addfootrule: TRUE               # Use if footers added. Add '#' to remove line.

# --------- page margins:
margin: 2.3 # Sides
bottom: 2 # bottom
top: 2.5 # Top
HardSet_layout: TRUE # Hard-set the spacing of words in your document. This will stop LaTeX squashing text to fit on pages, e.g.
# This is done by hard-setting the spacing dimensions. Set to FALSE if you want LaTeX to optimize this for your paper.

# --------- Line numbers
linenumbers: FALSE # Used when submitting to journal

# ---------- References settings:
# You can download cls format here: https://www.zotero.org/ - simply search for your institution. You can also edit and save cls formats here: https://editor.citationstyles.org/about/
# Hit download, store it in Tex/ folder, and change reference below - easy.
bibliography: Tex/ref.bib       # Do not edit: Keep this naming convention and location.
csl: Tex/harvard-stellenbosch-university.csl # referencing format used.
# By default, the bibliography only displays the cited references. If you want to change this, you can comment out one of the following:
#nocite: '@*' # Add all items in bibliography, whether cited or not
# nocite: |  # add specific references that aren't cited
#  @grinold2000
#  @Someoneelse2010

# ---------- General:
RemovePreprintSubmittedTo: TRUE  # Removes the 'preprint submitted to...' at bottom of titlepage
Journal: "Journal of Finance"   # Journal that the paper will be submitting to, if RemovePreprintSubmittedTo is set to TRUE.
toc: FALSE                       # Add a table of contents
numbersections: TRUE             # Should sections (and thus figures and tables) be numbered?
fontsize: 12pt                  # Set fontsize
linestretch: 1.2                # Set distance between lines.
link-citations: TRUE            # This creates dynamic links to the papers in reference list.

### Adding additional latex packages:
# header-includes:
#    - \usepackage{colortbl} # Add additional packages here.

output:
  pdf_document:
    keep_tex: TRUE
    template: Tex/TexDefault.txt
    fig_width: 3.5 # Adjust default figure sizes. This can also be done in the chunks of the text.
    fig_height: 3.5
abstract: |
 
---

<!-- First: Set your default preferences for chunk options: -->

<!-- If you want a chunk's code to be printed, set echo = TRUE. message = FALSE stops R printing ugly package loading details in your final paper too. I also suggest setting warning = FALSE and checking for warnings in R, else you might find ugly warnings in your paper. -->

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = FALSE, message = FALSE, warning = FALSE, fig.width = 6, fig.height = 5, fig.pos="H", fig.pos = 'H')
# Note: Include = FALSE implies the code is executed, but not printed in your pdf.
# warning and message = FALSE implies ugly messages and warnings are removed from your pdf.
# These should be picked up when you execute the command chunks (code sections below) in your rmd, not printed in your paper!

library(tidyverse)
library(lubridate)
library(fmxdat)
library(tbl2xts)
library(rmsfuns)
library(glue)
library(PortfolioAnalytics)
library(rugarch)
library(forecast)
library(gridExtra)
library(kableExtra)
# library(rmgarch)
library(MTS)
library(robustbase)
list.files('code/', full.names = T, recursive = T) %>% .[grepl('.R', .)] %>% as.list() %>% walk(~source(.))

```

```{r}
alsi_raw <- read_rds("data/ALSI.rds")
currency <- read_rds("data/USDZAR.rds")
repo_raw <- read.csv("data/HistoricalRateDetail.csv")
```

```{r}
#Lets rename the J403 to SWIX and J203 to ALSI and get them as different data sets. 
alsi_df <- alsi_raw %>% 
    rename("ALSI" = "J203", "SWIX"= "J403") %>% 
    mutate(ALSI = coalesce(ALSI,0)) %>% #This is what i should have done it the practical but we live and learn
    mutate(SWIX = coalesce(SWIX,0))

# Now I use a function that incorporates the rmsfuns safe portfolio returns
#I do this for all three sectors and for each fund
#SWIX
swix_fin<- calculate_sector_returns(data = alsi_df, sector_name = "Financials", fund_name = "SWIX") %>% 
    rename("Financials"="PortfolioReturn")

swix_rec<- calculate_sector_returns(alsi_df, "Resources", "SWIX") %>% 
    rename("Resources"="PortfolioReturn")

swix_ind <- calculate_sector_returns(alsi_df, "Industrials", "SWIX") %>% 
    rename("Industrials"="PortfolioReturn")

#ALSI
alsi_fin<- calculate_sector_returns(alsi_df, "Financials", "ALSI") %>% 
    rename("Financials"="PortfolioReturn")

alsi_rec<- calculate_sector_returns(alsi_df, "Resources", "ALSI") %>% 
    rename("Resources"="PortfolioReturn")

alsi_ind <- calculate_sector_returns(alsi_df, "Industrials", "ALSI") %>% 
    rename("Industrials"="PortfolioReturn")


#Now I just need to join them together into two data frames that will then be used to do the garch analysis
swix_portret <- 
    left_join(swix_fin, swix_rec, by = "date") %>% 
    left_join(. , swix_ind, by = "date")

alsi_portret <- 
    left_join(alsi_fin, alsi_rec, by = "date") %>% 
    left_join(., alsi_ind, by = "date")



```

```{r}
# Let's clean up the repo data a bit
repo<- repo_raw %>% 
    slice(-(1:2)) %>%
    rename("repo"= "Description") %>% 
    mutate(date = ymd(Indicator),
           repo = as.numeric(repo)/100) %>% 
    filter(date>ymd(20121231)) %>% 
    select(date, repo)


```

```{r}
library(tidyverse)
xts_rtn <- alsi_portret %>% 
    rename("FIN" = "Financials", "REC"= "Resources", "IND" = "Industrials") %>% # This is to get more easible readible paies
    left_join(., currency %>% mutate(EX = value/lag(value)-1) %>% filter(date > dplyr::first(date)) %>% select(date, EX), by = "date") %>% 
    tbl_xts()

```
<!-- ############################## -->
<!-- # Start Writing here: -->
<!-- ############################## -->

# Introduction \label{Introduction}

Diversification is the cornerstone of modern day finance, thus understanding the co-movements of assets is essential for any diversification or hedging strategy. @katzke2013south highlights that investors have a ``home-bias", where local assets are favoured over international assets. This can lead to risks of underdiversification when there is homogoneity in return movements between local sectors and assets. This project, therefore, aims to identify and investigate the co-movements of three of the largest sectors in South Africa.

The use of Mulitvariate Generalized Autoregressive Conditional Heteroskedasticity (MV-GARCH) to obtain dynamic conditional correlations has become more prevalent in finance and portfolio theory literature. It has been used for many different purposes. @ho2004analysis \& @katzke2013south employ MV-GARCH models to investigate diversification opportunities and threats through inter-sector correlations. @fakhfekh2021hedging \& @ali2022modelling instead look at hedging strategies utilising a vast array of different financial assets and instruments. 

In this paper I extract three sectors' returns from the All Share J203 in order to derive the time-varying correlations between the three sectors and the United States Dollar to South African Rand exchange rate. The rest of the paper is structured as follows, section two describes the data, section three desribes the methods and statistical tests used, section four presents the final results and lastly, section five concludes.


# Data 

The data used to get the sector returns is the All Share (ALSI) J203 index. This index represents 99% of the full market cap value of all eligible securities listed on the Main Board of the Johannesburg Stock Exchange (JSE) [@jse_website]. Sector returns are then created for the financial, industrial and resource sectors. All stocks categorised in each of these sectors is reweighted in order to create a index for each sector. The cumulative returns are presented in figure \ref{Figure1}. 

Other data that was used is the United States Dollar (USD) to South African Rand (ZAR) exchange rate as the depreciation or appreciation of the domestic currency compared to the Dollar is an indicator of changes in the global economy. Lastly the historical repurchase rate (REPO) was obtained from the South African Reserve Bank (SARB). 

```{r Figure1,  warning =  FALSE, fig.align = 'center', fig.cap = "Cumulative Returns of ALSI \\label{Figure1}", fig.ext = 'png', fig.height = 5, fig.width = 6}
cum_sectors<- alsi_portret %>% 
    gather(Sector, ret, -date) %>% 
    arrange(date) %>% 
    group_by(Sector) %>% 
    mutate(cum_rts = cumprod(1+ret)) %>% 
    select(-ret) %>% 
    ungroup() %>% 
    ggplot()+
    geom_line(aes(date, cum_rts, color = Sector))+
    fmxdat::theme_fmx()+
    labs(title = "Cumulative Returns of ALSI", subtitle = "By Sector", x = "Date", y = "Cumulative Returns", caption = "Note: Blue (red) shaded areas represent years of low (high) volatility of the REPO rate.")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) 
    

cum_sectors


```
# Methodology

I begin by conducting multiple tests for autoregressive conditional heteroskedasticity (ARCH) effects. I do this through graphing the returns, absolute returns and squared returns which can be found in figures \ref{FigureA1}, \ref{FigureA2} and \ref{FigureA3}. These figures highlights that the return series of all three sectors show strong first order persistence and potential periods of second order persistence. Lastly, it appears that the series has a long memory in the second order process. To check for this I conduct more formal tests for ARCH effects.

## Tests for Autoregressive Conditional Heteroskedasticity (ARCH) effects. 

The first formal test that I conduct is the plotting of the autocorrelation functions of the returns, absolute returns and squared returns for all sectors. Figures \ref{FigureA4}, \ref{FigureA5} and \ref{FigureA6} can be found in the appendix. These figures provide more evidence of conditional heteroskedasticity and long memory for all of the sectors. The last test is a formal Box-Ljung test where the null hypothesis is that there are no ARCH effects. Table 3.1 presents the results of the test and it is clear that the null hypothesis of no ARCH effects can be rejected at the 1% confidence level. This means that the condictional heteroskedasticity needs to be controlled for. 

```{r}
box_test_foo(alsi_portret, sectors = c("Financials", "Resources", "Industrials"))
```

## Univariate Model Selection
A univariate GARCH specification is necassary for the multivariate specification. There are a vast number of extentions to the original GARCH formulation, therefore to obtain the model that best fits the data I employ multiple information criteria to assess the potential model fits in the univariate case. Table 3.2 presents the results of the information criteria and the best model for each sector is different but on average the best fitting model across all sectors is eGARCH so that is the specification that will be used to estimate the dynamic conditional correlations.
```{r}

# Apply the GARCH model comparison to all sectors
sectors <- c("Financials", "Resources", "Industrials")
garch_results <- lapply(sectors, function(sector) garch_model_comparison(alsi_portret, sector))

# Combine the results into a single data frame
combined_results <- do.call(rbind, garch_results)

# Print the combined results as a nice table using kable
kable(combined_results, caption = "GARCH Model Comparison Results")

```

## Multivariate Models

Now that I have the univariate model specifications I can now fit the multivariate model. I fit three different multivariate GARCH models: DCC, aDCC and GO-GARCH. This follows the literature as the comparison between these two or three models is common [@fakhfekh2021hedging \& @katzke2013south \& @ali2022modelling ]. After fitting the DCC model I extract the model diagnostics that present multiple Portmanteau and rank based tests that assess whether there is serial correlation. @tsay2013 provides an in depth discussion about these tests. Th null hypothesis for all the tests are that there is no serial correlation and hence no conditional heteroskedasticity. @tsay2013[p. 403] notes that $Q_k (m)$ statistic works well when the distribution of innovations are normal but struggles when fatter tails are present . The robust statistic employs 5% trimming as a means to get a more robust statistic. The results presented in table \ref{Port} show that for all tests except for the robust version ($Q_r^{k} (m)$) rejects the null hypothesis of no conditional heteroskedasticity whereas the robust version fails to reject.

\begin{table}[htbp]
\centering
\caption{Portmanteau tests}
\label{Port}
\begin{tabular}{|c|c|c|c|}
\hline
$Q(m)$ & $Rank-based \ test$ & $Q_k(m)$ & $Q_r^{k} (m)$ \\
\hline
\hline
51.32 & 18.63 & 255.96 & 173.18 \\
(0.000) & (0.045) & (0.000) & (0.225) \\
\hline
\multicolumn{4}{|l|}{Note: P-values given in brackets.} \\
\hline
\end{tabular}
\end{table}

# Results
Figures \ref{Figure2}, \ref{Figure3} and \ref{Figure4} present the time varying conditional correlations between the three sectors of interest as well as the USD/ZAR exchange rate. Figure \ref{Figure2} presents the standard dynamic conditional correlations (DCC). \ref{Figure3} presents the assymetric dynamic conditional correlations (aDCC), which accounts for the assymetry of positive and negative shocks. Lastly, figure \ref{Figure4} presents the time varying correlations from a Generalized Orthogonal GARCH (GO-GARCH) specification. I also employed stratification methods to get the most and least volatile periods of the REPO rate. 

Across all of the specifications it is clear to see that during high periods of volatitlity in the REPO rate the correlations between the sectors is also more volatile. All specifications also highlight that there is large heterogeneity in the correlations over time. This serves as another motivating factor to not use time-invariant estimations of the correlations. The inter-sector correlations tend to move around 0.5 for both the DCC and aDCC with fluctuations within a band of 0.8 and 0. The correlation between the financial and industrial sectors is the highest followed by resources and industrials and then resources and financials. The correlations between the sectors and the exchange rate clearly show the financial sector is consistently negatively correlated with the exchange rate. For the other two sectors a positive correlation tends to be present during low volatility periods of the REPO and negative during high volatility periods.

There appears to be little difference between the DCC and aDCC specifications. When looking at GO-GARCH however, the correlations instead have much smaller fluctuations. @boswijk2006wake[p. 21] state that the smaller fluctuations can be seen as positive or a negative depending on the case. In this case it helps to provide a more consistent measure. The most important finding is that there does not seem to be a trend in any of the correlations.


```{r, results='hide'}
library(rmgarch)
#Now set the specifications for both the dcc and go-garch
#a) Set the Univaariate GARCH  spec (using aparch from the table above)
uspec <- ugarchspec(variance.model = list(model = "sGARCH", 
    garchOrder = c(1, 1)), mean.model = list(armaOrder = c(1, 
    0), include.mean = TRUE), distribution.model = "sstd")

# b) repeat the uspec n times 
multi_univ_garch_spec <- multispec(replicate(ncol(xts_rtn), uspec))

#c) now we set the DCC specs
spec.dcc = dccspec(multi_univ_garch_spec, dccOrder = c(1, 1), 
    distribution = "mvnorm", lag.criterion = c("AIC", "HQ", "SC", 
        "FPE")[1], model = c("DCC", "aDCC")[1]) # maybe come back and use aDCC and comparison between the three is prominant in the literature

# d) Enable clustering for speed:
cl = makePSOCKcluster(10)


# Step 2
# Fit the univariate series for each column
multf = multifit(multi_univ_garch_spec, xts_rtn, cluster = cl)

# Now we can use multf to estimate the dcc model using our
# dcc.spec:
fit.dcc = dccfit(spec.dcc, data = xts_rtn, solver = "solnp", 
    cluster = cl, fit.control = list(eval.se = FALSE), fit = multf)

# Testing the models fit: Tsay (2014)
RcovList <- rcov(fit.dcc)  # This is now a list of the monthly covariances of our DCC model series.
covmat = matrix(RcovList, nrow(xts_rtn), ncol(xts_rtn) * ncol(xts_rtn), 
    byrow = TRUE)
mc1 = MCHdiag(xts_rtn, covmat)



# Now to save the time-varying correlations as specified by
# the DCC model, it again requires some gymnastics from our
# side.  First consider what the list looks like:
dcc.time.var.cor <- rcor(fit.dcc)
# print(dcc.time.var.cor[, , 1:3])

# Now again follow the code in the prac to ensure we end up with bivariate pairs
# rather than lists of matrices
dcc.time.var.cor <- aperm(dcc.time.var.cor, c(3, 2, 1))
dim(dcc.time.var.cor) <- c(nrow(dcc.time.var.cor), ncol(dcc.time.var.cor)^2)

#For ease of extraction we call on the renaming dcc function 
dcc.time.var.cor <- renamingdcc(ReturnSeries = xts_rtn, DCC.TV.Cor = dcc.time.var.cor)
```

```{r Figure2,  warning =  FALSE, fig.align = 'center', fig.cap = "DCC  \\label{Figure2}", fig.ext = 'png', fig.height = 8, fig.width = 6}


#Now lets get the two plots
#Starting with financials
dcc_plot1 <- ggplot(dcc.time.var.cor %>% filter(grepl("FIN_", Pairs), 
    !grepl("_FIN", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Dynamic Conditional Correlations: Financials")+
       theme(axis.title.x = element_blank()) + 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)


#Now Resources
dcc_plot2 <- ggplot(dcc.time.var.cor %>% filter(grepl("REC_", Pairs), 
    !grepl("_REC", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Dynamic Conditional Correlations: Resources")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)

# Lastly for Industrials
dcc_plot3 <- ggplot(dcc.time.var.cor %>% filter(grepl("IND_", Pairs), 
    !grepl("_IND", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Dynamic Conditional Correlations: Industricals")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)


 grid.arrange(finplot(dcc_plot1), finplot(dcc_plot2), finplot(dcc_plot3), ncol = 1)

```


```{r, results='hide'}
spec.adcc = dccspec(multi_univ_garch_spec, dccOrder = c(1, 1), 
    distribution = "mvnorm", lag.criterion = c("AIC", "HQ", "SC", 
        "FPE")[1], model = c("DCC", "aDCC")[2]) # I now use the aDCC model spec

# d) Enable clustering for speed:
cl = makePSOCKcluster(10)


# Step 2
# Fit the univariate series for each column
multf = multifit(multi_univ_garch_spec, xts_rtn, cluster = cl)

fit.adcc = dccfit(spec.adcc, data = xts_rtn, solver = "solnp", 
    cluster = cl, fit.control = list(eval.se = FALSE), fit = multf)

# Testing the models fit: Tsay (2014)
RcovList <- rcov(fit.dcc)  # This is now a list of the monthly covariances of our DCC model series.
covmat = matrix(RcovList, nrow(xts_rtn), ncol(xts_rtn) * ncol(xts_rtn), 
    byrow = TRUE)
mc1 = MCHdiag(xts_rtn, covmat)



# Now to save the time-varying correlations as specified by
# the DCC model, it again requires some gymnastics from our
# side.  First consider what the list looks like:
adcc.time.var.cor <- rcor(fit.adcc)
# print(adcc.time.var.cor[, , 1:3])

# Now again follow the code in the prac to ensure we end up with bivariate pairs
# rather than lists of matrices
adcc.time.var.cor <- aperm(adcc.time.var.cor, c(3, 2, 1))
dim(adcc.time.var.cor) <- c(nrow(adcc.time.var.cor), ncol(adcc.time.var.cor)^2)

#For ease of extraction we call on the renaming dcc function 
adcc.time.var.cor <- renamingdcc(ReturnSeries = xts_rtn, DCC.TV.Cor = adcc.time.var.cor)
```

```{r Figure3,  warning =  FALSE, fig.align = 'center', fig.cap = "aDCC  \\label{Figure3}", fig.ext = 'png', fig.height = 8, fig.width = 6}
adcc_plot1 <- ggplot(dcc.time.var.cor %>% filter(grepl("FIN_", Pairs), 
    !grepl("_FIN", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Assymetric Dynamic Conditional Correlations: Financials")+
       theme(axis.title.x = element_blank())+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)


#Now Resources
adcc_plot2 <- ggplot(dcc.time.var.cor %>% filter(grepl("REC_", Pairs), 
    !grepl("_REC", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Assymetric Dynamic Conditional Correlations: Resources")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)

# Lastly for Industrials
adcc_plot3 <- ggplot(dcc.time.var.cor %>% filter(grepl("IND_", Pairs), 
    !grepl("_IND", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Assymetric Dynamic Conditional Correlations: Industricals")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)

 grid.arrange(finplot(adcc_plot1), finplot(adcc_plot2), finplot(adcc_plot3), ncol = 1)
```



```{r}
spec.go <- gogarchspec(multi_univ_garch_spec, 
                       distribution.model = 'mvnorm', 
                       ica = 'fastica') # Note: we use the fastICA
cl <- makePSOCKcluster(10)
multf <- multifit(multi_univ_garch_spec, xts_rtn, cluster = cl)

fit.gogarch <- gogarchfit(spec.go, 
                      data = xts_rtn, 
                      solver = 'hybrid', 
                      cluster = cl, 
                      gfun = 'tanh', 
                      maxiter1 = 40000, 
                      epsilon = 1e-08, 
                      rseed = 100)

gog.time.var.cor <- rcor(fit.gogarch)
gog.time.var.cor <- aperm(gog.time.var.cor,c(3,2,1))
dim(gog.time.var.cor) <- c(nrow(gog.time.var.cor), ncol(gog.time.var.cor)^2)
# Finally:
gog.time.var.cor <-
renamingdcc(ReturnSeries = xts_rtn, DCC.TV.Cor = gog.time.var.cor)
```


```{r Figure4,  warning =  FALSE, fig.align = 'center', fig.cap = "GO-GARCH  \\label{Figure4}", fig.ext = 'png', fig.height = 8, fig.width = 6}
go1 <- ggplot(gog.time.var.cor %>% filter(grepl("FIN_", Pairs), 
    !grepl("_FIN", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Go-GARCH: Financials")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)

go2 <- ggplot(gog.time.var.cor %>% filter(grepl("REC_", Pairs), 
    !grepl("_REC", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Go-GARCH: Resources")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)

go3 <- ggplot(gog.time.var.cor %>% filter(grepl("IND_", Pairs), 
    !grepl("_IND", Pairs))) + geom_line(aes(x = date, y = Rho, 
    colour = Pairs)) + theme_fmx() + ggtitle("Go-GARCH: Industrials")+ 
  annotate("rect", xmin = as.Date("2013-01-01"), xmax = as.Date("2013-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2018-01-01"), xmax = as.Date("2018-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2020-01-01"), xmax = as.Date("2020-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2021-01-01"), xmax = as.Date("2021-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "blue", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2022-01-01"), xmax = as.Date("2022-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3) +
  annotate("rect", xmin = as.Date("2023-01-01"), xmax = as.Date("2023-12-31"), 
           ymin = -Inf, ymax = Inf, fill = "red", alpha = 0.3)

 grid.arrange(finplot(go1), finplot(go2), finplot(go3), ncol = 1)

```

# Conclusion
This paper set out to estimate time-varying correlations of three sectors of the All Share index J203 as well as the USD/ZAR exchange rate. This was done by first fitting the multiple univariate GARCH models before evaluating the fit with multiple infomation criteria. Once the best univariate fit was selected it was used to fit the multivariate GARCH. The results show that the use of time-varying correlations are justified and if time-invariant correlations are used it will lead to an inefficiently diversified portfolio. Secondly, I found that the financial sector is the most suseptible to Rand depreciation while the other sectors correlations fluctuate around 0. 

<!-- Make title of bibliography here: -->
<!-- \newpage -->

\newpage

# References {-}

<div id="refs"></div>

\newpage
# Appendix 

```{r FigureA1,  warning =  FALSE, fig.align = 'center', fig.cap = "Return Persistence: Financials \\label{FigureA1}", fig.ext = 'png', fig.height = 3, fig.width = 6}
#I wrapped the code from the practical into a function where i just need to give the data (as a tbl) sector and it outputs the return persistence graphs
return_persistence_plotter(data = alsi_portret, sector =  "Financials")

```

```{r FigureA2,  warning =  FALSE, fig.align = 'center', fig.cap = "Return Persistence: Resources \\label{FigureA2}", fig.ext = 'png', fig.height = 3, fig.width = 6}
return_persistence_plotter(alsi_portret, "Resources")

```

```{r FigureA3,  warning =  FALSE, fig.align = 'center', fig.cap = "Return Persistence: Industrials \\label{FigureA3}", fig.ext = 'png', fig.height = 3, fig.width = 6}
return_persistence_plotter(alsi_portret, "Industrials")

```

```{r FigureA4,  warning =  FALSE, fig.align = 'center', fig.cap = "Autocorrelation Functions: Financials \\label{FigureA4}", fig.ext = 'png', fig.height = 3, fig.width = 6}
#here I again use the ggAcf, theme_fmx and finlot as well as gridExtra to get a nice plot of each sectors autocorrelation
acf_plotter(alsi_portret, "Financials")
```

```{r FigureA5,  warning =  FALSE, fig.align = 'center', fig.cap = "Autocorrelation Functions: Resources \\label{FigureA5}", fig.ext = 'png', fig.height = 3, fig.width = 6}
acf_plotter(alsi_portret, "Resources")

```

```{r FigureA6,  warning =  FALSE, fig.align = 'center', fig.cap = "Autocorrelation Functions: Industrials \\label{FigureA6}", fig.ext = 'png', fig.height = 3, fig.width = 6}
acf_plotter(alsi_portret, "Industrials")

```